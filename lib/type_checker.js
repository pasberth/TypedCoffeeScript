// Generated by CoffeeScript 2.0.0-beta8-dev
var checkNodes, console, CS, g, initializeGlobalTypes, pj, render, Scope, TypeSymbol, VarSymbol, walk, walk_arrayInializer, walk_assignOp, walk_binOp, walk_block, walk_bool, walk_class, walk_classProtoAssignOp, walk_conditional, walk_for, walk_function, walk_functionApplication, walk_identifier, walk_memberAccess, walk_newOp, walk_numbers, walk_objectInitializer, walk_primitives, walk_program, walk_range, walk_return, walk_string, walk_struct, walk_switch;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
CS = require('./nodes');
cache$ = require('./types');
initializeGlobalTypes = cache$.initializeGlobalTypes;
VarSymbol = cache$.VarSymbol;
TypeSymbol = cache$.TypeSymbol;
Scope = cache$.Scope;
g = 'undefined' !== typeof window && null != window ? window : global;
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  if (g._root_) {
    root = g._root_;
  } else {
    g._root_ = root = new Scope;
    root.name = 'root';
    for (var cache$1 = [
          'global',
          'exports',
          'module'
        ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
      i = cache$1[i$];
      root.addVar(i, 'Any', true);
    }
    initializeGlobalTypes(root);
  }
  walk(cs_ast, root);
  Scope.dump(root);
  return root;
};
walk_struct = function (node, scope) {
  if (node.name instanceof Object) {
    return scope.addType(node.name.base, node.expr, [node.name.target]);
  } else {
    return scope.addType(node.name, node.expr);
  }
};
walk_program = function (node, scope) {
  walk(node.body.statements, scope);
  return node.annotation = { type: 'Program' };
};
walk_block = function (node, scope) {
  var last_annotation;
  walk(node.statements, scope);
  last_annotation = null != node.statements[node.statements.length - 1] ? node.statements[node.statements.length - 1].annotation : void 0;
  return node.annotation = last_annotation;
};
walk_return = function (node, scope) {
  walk(node.expression, scope);
  if (null != (null != node.expression && null != node.expression.annotation ? node.expression.annotation.type : void 0)) {
    scope.addReturnable(node.expression.annotation.type);
    return node.annotation = node.expression.annotation;
  }
};
walk_binOp = function (node, scope) {
  var left_type, right_type;
  walk(node.left, scope);
  walk(node.right, scope);
  left_type = null != node.left && null != node.left.annotation ? node.left.annotation.type : void 0;
  right_type = null != node.right && null != node.right.annotation ? node.right.annotation.type : void 0;
  if (left_type && right_type) {
    if (left_type === 'String' || right_type === 'String') {
      return node.annotation = { type: 'String' };
    } else if (left_type === right_type) {
      return node.annotation = { type: left_type };
    }
  } else {
    return node.annotation = { type: 'Any' };
  }
};
walk_conditional = function (node, scope) {
  var alternate_annotation, annotation, possibilities, type;
  walk(node.condition, scope);
  walk(node.consequent, scope);
  if (null != node.alternate)
    walk(node.alternate, scope);
  alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : { type: 'Undefined' };
  possibilities = [];
  for (var cache$1 = [
        null != node.consequent ? node.consequent.annotation : void 0,
        alternate_annotation
      ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
    annotation = cache$1[i$];
    if (!('undefined' !== typeof annotation && null != annotation))
      continue;
    if (null != (null != annotation.type ? annotation.type.possibilities : void 0)) {
      for (var i$1 = 0, length$1 = annotation.type.possibilities.length; i$1 < length$1; ++i$1) {
        type = annotation.type.possibilities[i$1];
        possibilities.push(type);
      }
    } else if (null != annotation.type) {
      possibilities.push(annotation.type);
    }
  }
  return node.annotation = { type: { possibilities: possibilities } };
};
walk_switch = function (node, scope) {
  var alternate_annotation, c, cond, possibilities;
  walk(node.expression, scope);
  for (var i$ = 0, length$ = node.cases.length; i$ < length$; ++i$) {
    c = node.cases[i$];
    for (var i$1 = 0, length$1 = c.conditions.length; i$1 < length$1; ++i$1) {
      cond = c.conditions[i$1];
      walk(c, scope);
    }
    walk(c.consequent, scope);
  }
  walk(node.consequent, scope);
  if (null != node.alternate)
    walk(node.alternate, scope);
  alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : { type: 'Undefined' };
  possibilities = [];
  for (var i$2 = 0, length$2 = node.cases.length; i$2 < length$2; ++i$2) {
    c = node.cases[i$2];
    if (!(null != c.annotation))
      continue;
    possibilities.push(c.consequent.annotation);
  }
  possibilities.push(alternate_annotation.type);
  return node.annotation = { type: { possibilities: possibilities } };
};
walk_newOp = function (node, scope) {
  return node.annotation = { type: scope.getTypeInScope(node.ctor.data) };
};
walk_for = function (node, scope) {
  var nop, type;
  walk(node.target, scope);
  if (null != node.valAssignee)
    scope.addVar(node.valAssignee.data, null != (null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0) ? null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0 : 'Any');
  if (null != node.keyAssignee)
    scope.addVar(node.keyAssignee.data, null != (null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0) ? null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0 : 'Any');
  if (null != node.valAssignee)
    if (null != (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0)) {
      scope.checkAcceptableObject(node.valAssignee.annotation.type, node.target.annotation.type.array);
    } else if ((null != node.target && null != node.target.annotation ? node.target.annotation.type : void 0) instanceof Object) {
      if (node.target.annotation.type instanceof Object) {
        for (nop in node.target.annotation.type) {
          type = node.target.annotation.type[nop];
          scope.checkAcceptableObject(node.valAssignee.annotation.type, type);
        }
      }
    }
  walk(node.body, scope);
  node.annotation = null != node.body ? node.body.annotation : void 0;
  delete scope._vars[null != node.valAssignee ? node.valAssignee.data : void 0];
  return delete scope._vars[null != node.keyAssignee ? node.keyAssignee.data : void 0];
};
walk_classProtoAssignOp = function (node, scope) {
  var left, right, symbol;
  left = node.assignee;
  right = node.expression;
  walk(right, scope);
  walk(left, scope);
  symbol = left.data;
  if (null != right.annotation)
    return scope.addThis(symbol, right.annotation.type);
};
walk_assignOp = function (node, scope) {
  var is_registered, left, pre_registered_annotation, registered, right, symbol;
  pre_registered_annotation = node.assignee.annotation;
  left = node.assignee;
  right = node.expression;
  walk(right, scope);
  walk(left, scope);
  if (null != left.annotation)
    scope.addVar(symbol, left.annotation.type);
  if (null != (null != left.annotation ? left.annotation.type : void 0))
    left.annotation.type = scope.getVar(symbol);
  if (left['instanceof'](CS.Identifier)) {
    symbol = left.data;
    registered = scope.getVarInScope(symbol);
    is_registered = !!registered;
    if (scope.getVarInScope(symbol) && pre_registered_annotation) {
      throw new Error('double bind: ' + symbol);
    } else if (null != left.annotation.type) {
      if (left.annotation.type === 'Any') {
        return scope.addVar(symbol, 'Any', true);
      } else if (right['instanceof'](CS.ForIn)) {
        return scope.checkAcceptableObject(left.annotation.type.array, right.annotation.type);
      } else if (null != left.annotation.type.args && null != right.annotation.type.args) {
        scope.checkFunctionLiteral(left.annotation.type, right.annotation.type);
        return scope.addVar(symbol, left.annotation.type);
      } else {
        if (null != right.annotation && null != left.annotation)
          scope.checkAcceptableObject(left.annotation.type, right.annotation.type);
        return scope.addVar(symbol, left.annotation.type);
      }
    }
  } else if (left['instanceof'](CS.MemberAccessOp)) {
    if (left.expression.raw === '@')
      return;
    if (null != (null != left.annotation ? left.annotation.type : void 0) && null != (null != right.annotation ? right.annotation.type : void 0))
      if (left.annotation.type !== 'Any') {
        return scope.checkAcceptableObject(left.annotation.type, right.annotation.type);
      }
  } else {
    return scope.addVar(symbol, 'Any');
  }
};
walk_primitives = function (node, scope) {
  switch (false) {
  case !node['instanceof'](CS.String):
    return walk_string(node, scope);
  case !node['instanceof'](CS.Bool):
    return walk_bool(node, scope);
  case !node['instanceof'](CS.Numbers):
    return walk_numbers(node, scope);
  }
};
walk_string = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    type: 'String',
    primitive: true
  };
};
walk_numbers = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    type: 'Number',
    primitive: true
  };
};
walk_bool = function (node, scope) {
  return null != node.annotation ? node.annotation : node.annotation = {
    type: 'Boolean',
    primitive: true
  };
};
walk_identifier = function (node, scope) {
  if (scope.getVarInScope(node.data)) {
    return node.annotation = { type: scope.getVarInScope(node.data) };
  } else {
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = { type: 'Any' };
  }
};
walk_memberAccess = function (node, scope) {
  var type;
  if (node['instanceof'](CS.SoakedMemberAccessOp)) {
    walk(node.expression, scope);
    type = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.type : void 0);
    if (null != type) {
      return node.annotation = {
        type: {
          possibilities: [
            'Undefined',
            type[node.memberName]
          ]
        }
      };
    } else {
      return node.annotation = { type: 'Any' };
    }
  } else if (node['instanceof'](CS.MemberAccessOp)) {
    walk(node.expression, scope);
    type = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.type : void 0);
    if (null != type) {
      return node.annotation = { type: type[node.memberName] };
    } else {
      return node.annotation = { type: 'Any' };
    }
  }
};
walk_arrayInializer = function (node, scope) {
  walk(node.members, scope);
  return null != node.annotation ? node.annotation : node.annotation = {
    type: {
      array: null != node.members ? node.members.map(function (m) {
        return null != m.annotation ? m.annotation.type : void 0;
      }) : void 0
    }
  };
};
walk_range = function (node, scope) {
  return node.annotation = { type: { array: 'Number' } };
};
walk_objectInitializer = function (node, scope) {
  var cache$1, expression, key, nextScope, obj;
  obj = {};
  nextScope = new Scope(scope);
  nextScope.name = 'object';
  for (var i$ = 0, length$ = node.members.length; i$ < length$; ++i$) {
    {
      cache$1 = node.members[i$];
      expression = cache$1.expression;
      key = cache$1.key;
    }
    if (!('undefined' !== typeof key && null != key))
      continue;
    walk(expression, nextScope);
    obj[key.data] = null != expression.annotation ? expression.annotation.type : void 0;
  }
  return null != node.annotation ? node.annotation : node.annotation = { type: obj };
};
walk_class = function (node, scope) {
  var classScope, fname, obj, val;
  classScope = new Scope(scope);
  walk(node.body, classScope);
  if (null != node.nameAssignee ? node.nameAssignee.data : void 0) {
    obj = {};
    for (fname in classScope._this) {
      val = classScope._this[fname];
      obj[fname] = val.type;
    }
    return scope.addType(node.nameAssignee.data, obj);
  }
};
walk_function = function (node, scope) {
  var args, functionScope, last_expr;
  args = null != node.parameters ? node.parameters.map(function (param) {
    return null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any';
  }) : void 0;
  node.annotation.type.args = args;
  functionScope = new Scope(scope);
  functionScope.name = 'function';
  if (null != node.parameters)
    node.parameters.map(function (param) {
      try {
        if ('function' === typeof functionScope.addVar)
          return functionScope.addVar(param.data, null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any');
      } catch (e$) {
        return 'ignore but brake on somewhere. why?';
      }
    });
  walk(node.body, functionScope);
  if ((null != node.annotation && null != node.annotation.type ? node.annotation.type.returns : void 0) !== 'Any') {
    last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
    return scope.checkAcceptableObject(node.annotation.type.returns, null != last_expr.annotation ? last_expr.annotation.type : void 0);
  } else {
    last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
    if (null != node.annotation)
      return node.annotation.type.returns = null != last_expr && null != last_expr.annotation ? last_expr.annotation.type : void 0;
  }
};
walk_functionApplication = function (node, scope) {
  var arg, args;
  for (var i$ = 0, length$ = node['arguments'].length; i$ < length$; ++i$) {
    arg = node['arguments'][i$];
    walk(arg, scope);
  }
  walk(node['function'], scope);
  node.annotation = { type: null != node['function'].annotation && null != node['function'].annotation.type ? node['function'].annotation.type.returns : void 0 };
  if (node['function'].annotation) {
    args = null != node['arguments'] ? node['arguments'].map(function (arg) {
      return null != arg.annotation ? arg.annotation.type : void 0;
    }) : void 0;
    return scope.checkFunctionLiteral(node['function'].annotation.type, {
      args: null != args ? args : [],
      returns: 'Any'
    });
  }
};
walk = function (node, scope) {
  console.log('---', null != node ? node.className : void 0, '---', null != node ? node.raw : void 0);
  switch (false) {
  case !!(null != node):
    return;
  case !(null != node.length):
    return function (accum$) {
      var s;
      for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
        s = node[i$];
        accum$.push(walk(s, scope));
      }
      return accum$;
    }.call(this, []);
  case !(node.type === 'struct'):
    return walk_struct(node, scope);
  case !node['instanceof'](CS.Program):
    return walk_program(node, scope);
  case !node['instanceof'](CS.Block):
    return walk_block(node, scope);
  case !node['instanceof'](CS.Return):
    return walk_return(node, scope);
  case !node['instanceof'](CS.NewOp):
    return walk_newOp(node, scope);
  case !(node['instanceof'](CS.PlusOp) || node['instanceof'](CS.MultiplyOp) || node['instanceof'](CS.DivideOp) || node['instanceof'](CS.SubtractOp)):
    return walk_binOp(node, scope);
  case !node['instanceof'](CS.Switch):
    return walk_switch(node, scope);
  case !node['instanceof'](CS.Conditional):
    return walk_conditional(node, scope);
  case !(node['instanceof'](CS.ForIn) || node['instanceof'](CS.ForOf)):
    return walk_for(node, scope);
  case !node['instanceof'](CS.Primitives):
    return walk_primitives(node, scope);
  case !node['instanceof'](CS.Identifier):
    return walk_identifier(node, scope);
  case !node['instanceof'](CS.ClassProtoAssignOp):
    return walk_classProtoAssignOp(node, scope);
  case !node['instanceof'](CS.MemberAccessOps):
    return walk_memberAccess(node, scope);
  case !node['instanceof'](CS.ArrayInitialiser):
    return walk_arrayInializer(node, scope);
  case !node['instanceof'](CS.Range):
    return walk_range(node, scope);
  case !node['instanceof'](CS.ObjectInitialiser):
    return walk_objectInitializer(node, scope);
  case !node['instanceof'](CS.Class):
    return walk_class(node, scope);
  case !node['instanceof'](CS.Function):
    return walk_function(node, scope);
  case !node['instanceof'](CS.FunctionApplication):
    return walk_functionApplication(node, scope);
  case !node['instanceof'](CS.AssignOp):
    return walk_assignOp(node, scope);
  }
};
module.exports = { checkNodes: checkNodes };
